# GeneralPlotter

## Описание

**GeneralPlotter** — это инструмент на Rust для визуализации данных с COM-порта, блютуз-устройств и различных API, TCP соединений, и построения их графических представлений.

Цель проекта — предоставить гибкий механизм построения и отображения графиков на основе получаемых данных, с возможностью расширения.

---

## Основные возможности

* Приложение на Rust для приёма и данных с расзличных устройств/методов;
* Веб-интерфейс (wasm) для визуализации результатов;
* Desktop-прлиожение (egui) для визуализации;
* Возможность подключения внешних Python/других клиентов для обмена сообщениями;
* Экспорт данных в csv формат.

---

## Архитектура

Проект разделён на несколько ключевых компонентов:

```
GeneralPlotter/
├── src/              # Исходный код сервера на Rust
├── assets/           # Стили, скрипты, графические ресурсы
├── infra/            # Сборочные и конфигурационные скрипты
├── .vscode/          # Настройки среды VSCode (опционально)
├── index.html        # Шаблон клиентского интерфейса
├── Cargo.toml        # Конфигурация Rust-проекта
├── Trunk.toml        # Конфигурация для сборки Web UI
└── README.md         # Документация
```

---


## Установка и сборка

1. **Клонирование репозитория**

```bash
git clone https://github.com/LicrimoVor/GeneralPlotter.git
cd GeneralPlotter
```

2. **Сборка проекта**

```bash
cargo build --release
```

Если проект включает web-компоненты (например, с Trunk):

```bash
trunk build --release
```

3. **Запуск сервера**

```bash
cargo run
```

После запуска сервер будет слушать указанный в конфигурации TCP-порт (например, `127.0.0.1:7878`, если используется по умолчанию).

---

## Протокол взаимодействия

Для взаимодействия между клиентом и сервером определяется простой текстовый протокол поверх TCP:

* Каждое сообщение должно заканчиваться переходом строки (`\n`).
* Сервер ожидает команды от клиента и отправляет ответы по мере обработки.
* Для проверки правильности обмена данных рекомендуется использовать heartbeat/пинг-сообщения и корректную обработку указателей конца строки (если сервер ожидает `\n`).

> Обратите внимание: Реализация Python-клиента должна соответствовать ожиданиям сервера по формату (например, отправка строк с `\n`). Если они не совпадают, сообщения могут приниматься, но не обрабатываться должным образом.

---

## Пример Python-клиента

```python
import socket

HOST = "127.0.0.1"
PORT = 7878

with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
    s.connect((HOST, PORT))
    while True:
        msg = input("Введите команду: ")
        if msg.lower() == "exit":
            break
        s.sendall((msg + "\n").encode("utf-8"))
        data = s.recv(512)
        if not data:
            break
        print("Ответ:", data.decode("utf-8").strip())
```

---

## Примеры использования

В зависимости от реализованной логики на сервере можно отправлять команды для:

* обновления графиков,
* задания параметров визуализации,
* запроса текущего состояния,
* остановки/перезапуска определённых модулей.

---
